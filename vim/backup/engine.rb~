class Promotion
  class Engine

    def self.create_promotion_instance(customer: nil, product: nil, promotion: nil)
      error = validate(customer || product.customer, product || customer.try(:ongoing_application), promotion)
      return error if error
      pi = (product || customer.ongoing_application).promotion_instances.build
      pi.customer_application = product.customer.ongoing_application if product.present?
      pi.status = 'associated'
      pi.coupon_code = promotion.coupon_code
      pi.promotion = promotion
      if pi.save then return nil else return "Coupon code could not be associated." end
    end

    def self.promotion_already_applied?(item, promotion)
      item.promotions.each do |applied_promo|
        return true if applied_promo.id == promotion.id
      end
      false
    end

    def self.inactive_date?(promotion)
      return true if promotion.start_date && Date.today < promotion.start_date
      return true if promotion.end_date && Date.today > promotion.end_date
      false
    end

    def self.unstackable(item, promotion)
      all_promotions = []
      all_promotions << promotion
      all_promotions.concat item.promotions

      all_promotions.sort_by{|p| p.priority}.each_with_index do |promo, index|
        return true if promo.stop_rule_processing && index < all_promotions.length - 1
      end
      false
    end

    def self.validate(customer, item, promotion)
      return "Promotion was not passed." unless promotion.present? && promotion.is_a?(Promotion)
      return "Promotable is invalid." unless item.present? && (item.is_a?(Loan) || item.is_a?(CustomerApplication))
      return "Customer is invalid." unless customer.present? && customer.is_a?(Customer)
      return "Promotion already associated." if promotion_already_applied?(item, promotion)
      return "This promotion is not currently active." if !promotion.enabled? || inactive_date?(promotion)
      return "This promotion requires a previously issued loan." if promotion.require_previous_loan && !customer.prior_paid_loan?
      return "This promotion requires this to be your first loan." if promotion.require_first_loan && customer.prior_paid_loan?
      return "You have already used this promotion the max amount." if promotion.uses_per_customer.try(:>, 0) && promotion.uses_per_customer.try(:>, 0) && customer.promotion_uses(promotion) >= promotion.uses_per_customer
      return "You can not combine this promotion with your currently entered promotions." if unstackable(item, promotion)
      return nil
    end

    def self.calculate_discount(product, promotion)
      if promotion.rule_type == 'fixed_discount'
        return fixed_discount_amount(product, promotion)
      end
      return 0
    end

    def self.fixed_discount_amount(product, promotion)
      if product.payoff_amount < promotion.rule_amount_to_money
        return product.payoff_amount
      else
        return promotion.rule_amount_to_money
      end
    end
  end
end
