require "test_helper"

module Test
  class JobProcessor
    include Resque::AvantCreditBaseWorker

    retryable_tasks :job_with_retry, :job_with_retry_error

    def do_nothing
      #do nothing
    end

    def spawn_child_jobs
      3.times {
        Test::JobProcessor.create({'job' => 'do_nothing', 'parent_job_uuid' => self.uuid})
      }
    end

    def job_with_error
      raise "job with error"
    end

    def no_method_error_on_nil_object
      nil.some_method
    end

    def job_with_retry
    end

    def job_with_retry_error
      raise "this is an error"
    end
  end

  class OverrideQueueJobProcessor
    include Resque::AvantCreditBaseWorker
    @queue = :critical
    @retry_limit = 5
  end

  class JobWithCallbacks
    include Resque::AvantCreditBaseWorker

    attr_reader :hook_count

    def initialize(*args)
      @hook_count = []
      super
    end

    def do_nothing

    end

    def before_perform
      @hook_count << :before_perform
    end

    def before_perform_something_else
      @hook_count << :before_perform_something_else
    end
  end
end

describe "Avant Credit Base Worker" do
  let(:options)  { {"job" => "do_nothing"} }
  let(:test_job) { Test::JobProcessor.new(Time.now.to_i, options) }
  before do
    JobEvent.delete_all
    Resque.enable_hooks!
    ENV['JOB_TRACKING_ENABLED'] = '1'
  end

  after do
    Resque.disable_hooks!
    ENV['JOB_TRACKING_ENABLED'] = nil
  end

  def perform_job!(job)
    job.safe_perform!
  end

  it "sets failed on missing job type" do
    options['job'] = %w{these are not the droids you are looking for}.join("_")
    assert_raises(Resque::AvantCreditBaseWorker::MissingJobMethodError) { perform_job!(test_job) }
    assert_equal "failed", test_job.status['status']
  end

  it "sets completed on completed job" do
    perform_job!(test_job)
    assert_equal "completed", test_job.status['status']
  end

  it "defaults queue to :normal" do
    assert_equal :normal, Test::JobProcessor.queue
  end

  it "supports overriding the queue" do
    assert_equal :critical, Test::OverrideQueueJobProcessor.queue
  end

  describe "job status tracking" do
    def create_job(opts = nil)
      Test::JobProcessor.create(opts || options)
    end

    it "should create a job event record" do
      assert_difference "JobEvent.count", 1 do
        create_job
        Resque.run!
      end
    end

    it "should set the proper event attributes" do
      @uuid = create_job
      status = Resque::Plugins::Status::Hash.get(@uuid)
      stats = status['tracking_options']
      assert_equal(@uuid, stats["uuid"])
      assert_equal("Test::JobProcessor", stats["job_class"])
      assert_equal("do_nothing", stats["job_name"])

      Resque.run!
      status = Resque::Plugins::Status::Hash.get(@uuid)

      job_event = JobEvent.first
      assert_equal(@uuid, job_event.uuid)
      assert_equal("do_nothing", job_event.job_name)
      assert_equal("Test::JobProcessor", job_event.job_class)
    end

    it "Should track when created from a parent job" do
      @uuid = create_job({'job' => 'spawn_child_jobs'})

      # run twice to run spawned jobs.
      # Using Resque.full_run! hangs forever here, so don't use it.
      Resque.run!; Resque.run!

      job_event = JobEvent.first
      assert_equal(@uuid, job_event.uuid)
      child_events = JobEvent.where(spawned_from: @uuid)
      assert_equal(3, child_events.count)
    end

    it "should get updated once the job runs" do
      @uuid = create_job
      Resque.run!

      job_event = JobEvent.first
      assert_equal(@uuid, job_event.uuid)
      # assert(job_event.in_time.nil?, "Should not have times set.")

      # job_event.reload

      refute(job_event.in_time.nil?, "in_time should not be nil")
      refute(job_event.out_time.nil?, "out_time should not be nil")
    end

    it "should set the job status" do
      @completed_uuid = create_job
      @killed_uuid    = create_job
      # @failed_uuid    = create_job({'job' => 'job_with_error'})

      Resque::Plugins::Status::Hash.kill(@killed_uuid)
      Resque.run!

      completed_event = JobEvent.where(uuid: @completed_uuid).first
      killed_event    = JobEvent.where(uuid: @killed_uuid).first
      # binding.pry
      assert_equal("completed", completed_event.result)
      assert_equal("killed", killed_event.result)
    end

    it "should set the job status when there is an error" do
      @failed_uuid = create_job({'job' => 'job_with_error'})
      # this will raise the error from the job, thus it is rescued
      Resque.run! rescue nil
      failed_event    = JobEvent.where(uuid: @failed_uuid).first
      assert_equal("failed", failed_event.result)
    end
  end

  describe "instance hooks" do
    before do
      @job = Test::JobWithCallbacks.new(Time.now.to_i, options)
    end

    it "should run before callbacks" do
      assert(@job.hook_count.empty?, "Should have no called hooks")
      perform_job!(@job)

      assert_equal [:before_perform, :before_perform_something_else], @job.hook_count
    end
  end


  describe 'Retry' do
    let(:retry_job) { Test::JobProcessor.new(Time.now, {"job" => "job_with_retry"}) }

    it "should have a default retry limit" do
      assert_equal(10, Test::JobProcessor.retry_limit)
    end

    it 'can modify the default retry limit' do
      assert_equal(10, Test::JobProcessor.retry_limit)
      assert_equal(5, Test::OverrideQueueJobProcessor.retry_limit)
    end

    describe "When performing the job raises an error" do
      let(:retry_error_job) { Test::JobProcessor.new(Time.now, {"job" => "job_with_retry_error", 'base_worker_retries_count' => 0}) }
      it 'will call #retry_job' do
        retry_error_job.expects(:retry_job!).once
        perform_job!(retry_error_job)
      end

      it 'will re-enqueue the job' do
        assert_queued(Test::JobProcessor) { retry_error_job.retry_job! }
      end

      it 'should set status to "failed"' do
        perform_job!(retry_error_job)
        assert retry_error_job.status.failed?, %{Should be failed but was '#{retry_error_job.status["status"]}'}
      end

      it "should track number of retries" do
        assert_difference "retry_error_job.retry_attempts", 1 do
          perform_job!(retry_error_job)
        end
      end

      it "should raise error after retry_limit is reached" do
        retry_error_job.stubs(retry_attempts: 10)
        assert_raises(Resque::AvantRetryable::RetryLimitError) { retry_error_job.retry_job! }
      end
    end

    it "should be #retryable?" do
      assert(retry_job.retryable?, "Job should be #retryable?")
    end

    it 'will NOT raise an error' do
      begin
        perform_job!(retry_job)
      rescue => e
        flunk("Job should not raise an error but fails with: #{e.class}: #{e.message}")
      end
    end

    it "will not retry a job that succeeds" do
      assert_not_queued(Test::JobProcessor){
        perform_job!(retry_job)
      }
    end
  end

  describe "When it receives a sig term" do

    before do
      @test_job = Test::JobProcessor.new(Time.now, {"job" => "job_with_retry"})
      @test_job.stubs(:job_with_retry).raises(Resque::TermException.new('SIGTERM'))
    end

    it 'should re-enqueue when a sigterm is handled' do
      perform_job!(@test_job)
      assert_queued(Test::JobProcessor)
    end

    it 'should update the status when a sigterm is handled' do
      perform_job!(@test_job)
      assert_equal "killed", @test_job.status['status']
    end

    it 'should NOT reraise an error' do
      perform_job!(@test_job)
    end
  end

end
