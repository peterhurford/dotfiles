module CreditModel
  # Generate additional credit model information for a credit_decision
  # not necessarily obtainable from a query
  class DataGatherer
    include Nillify

    def self.for_credit_decision_and_source(credit_decision, data_source)
      unless credit_decision.is_a?(::CreditDecision)
        raise TypeError.new("Expected a CreditDecision")
      end
      unless data_source.is_a?(klass = ::CreditModel::CreditModelDataSourceRails)
        raise TypeError.new("Expected a #{klass.name}")
      end
      self.new credit_decision, data_source
    end

    def initialize(credit_decision, data_source)
      @credit_decision = credit_decision
      @data_source = data_source
    end

    def data
      @data ||= data_lambdas
        .slice(*@data_source.additional_variables.map(&:to_sym))
        .map { |k,v| { k => nillify(v) } }
        .reduce(:merge)
    end

    def customer_application
      @customer_application ||=
        @credit_decision.customer.customer_applications.started.
          where("created_at <= ?", @credit_decision.created_at).
            order("created_at desc").first
    end

    def data_lambdas
      {
        loan_purpose: -> {
          @customer_application.information.try(:partial_application)[:loan_purpose]
        },
        product_name: -> {
          @credit_decision.inputs[:original_product_name] ||
          @credit_decision.decision_information[:product_name]
        },
        income: -> {
          (@credit_decision.inputs[:monthly_net_income] ||
            (@credit_decision.customer.income.monthly_net_income_cents / 100.0)
          ).to_f },
        source: -> {
            @customer_application.try(:lead).try(:source) ||
            @credit_decision.inputs[:source] ||
            customer_application.source },
        state: -> { @credit_decision.inputs[:state] || @credit_decision.customer.state }
      }
    end

  end
end

