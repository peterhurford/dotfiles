require 'test_helper'
class ModelNotRecognizedError; end

# These tests ensure Avant is in compliance with the WebBank Credit Policy
# by reading the pol[icy from a YAML file and dynamically generating scenarios that conclift with the policy
# and testing to make sure those scenarios don't pass.
describe 'WebBank Credit Policy' do
  # Test compliance with the WebBank credit policy by using the credit policy yaml file to generate
    # scenarios that conflict with the policy, and make sure none of those scenarios result in issued loans.

  policy = YAML.load_file(File.join(Rails.root, 'etc', 'webbank_credit_policy.yml'))
  rules = {
    'Credit Decision I' => policy['credit_decision_I'],
    'Credit Decision II' => policy['credit_decision_II'],
    'Loan Terms Summary I' => policy['loan_terms_summary_I'],
    'Loan Terms Summary II' => policy['loan_terms_summary_II']
  }
  webbank_owned_params = {
    vantage_score: 660,
    dob: Date.new(1990, 12, 12),
    income_type: "employment",
    state: "IL",
    monthly_net_income: 3000,
    fico_score: 601,
    count_tradelines: 15,
    amount_monthly_minimum_payments: 0,
    count_non_student_open_tradelines: 5,
    count_120_days_past_due_active_tradelines: 0,
    amount_non_medical_collections: 0,
    amount_past_due_on_open_tradelines: 0,
    has_open_bankruptcy: false,
    iovation_result_type: "X",
    promotion_code: "loan50",
    is_premium_lead_source: false,
    locale: :'en-US',
    product_owner: 'webbank'
  }

  describe "Base Case" do
    it "should work in the base case" do
      customer = FactoryGirl.create(:customer, credit_decisions: [])
      force_tier_by_fico_score!(:silver)
      customer.run_credit_reports!
      customer.run_decision_logic!
      expect_this_cd_to_succeed = customer.current_or_new_decision.dup
      expect_this_cd_to_succeed.inputs[:product_owner] = 'webbank'
      expect_this_cd_to_succeed.decision_information[:apr] = CPMLInterpreter.interpret(policy['loan_terms_summary_I']['apr'])[:operand]
      expect_this_cd_to_succeed.model_decline_score = CPMLInterpreter.interpret(policy['loan_terms_summary_II']['model_decline_score'])[:operand]
      expect_this_cd_to_succeed.approved = true
      expect_this_cd_to_succeed.save
      assert(expect_this_cd_to_succeed.approved?)

      cde = CreditDecisionEngine.new(webbank_owned_params)
      assert(cde.approved?)
    end
  end

  rules.each do |model, policy|
    describe "#{model}" do
      policy.each do |var, requirement|
        it "credit decisions comply with the WebBank rule about #{var}" do
          if var == "clarity_deliquent_open_or_active_loans"  # Skip these problematic variables (TODO: fix)
            assert(true)
          else
            data = CPMLInterpreter.interpret(requirement, webbank_owned_params)
            operator = data[:operator]
            operand = data[:operand]
            conflicting_operand = generate_conflicting_operand(operator, operand)

            if model == 'Credit Decision I' or model == 'Credit Decision II'
              force_tier_by_fico_score!(:silver)
              expect_these_params_to_fail = webbank_owned_params.deep_dup
              expect_these_params_to_fail[var.to_sym] = conflicting_operand
              expect_this_cd_to_fail = CreditDecisionEngine.new(expect_these_params_to_fail)
              binding.pry
              refute(expect_this_cd_to_fail.approved?)

            elsif model == 'Loan Terms Summary I' or model == 'Loan Terms Summary II'
              customer = FactoryGirl.create(:customer, credit_decisions: [])
              force_tier_by_fico_score!(:silver)
              customer.run_credit_reports!
              customer.run_decision_logic!
              expect_this_cd_to_fail = customer.current_or_new_decision.dup
              expect_this_cd_to_fail.inputs.merge!(webbank_owned_params)
              expect_this_cd_to_fail.decision_information[:apr] = 0.35
              expect_this_cd_to_fail.approved = true
              if model == 'Loan Terms Summary I'
                expect_this_cd_to_fail.decision_information[var.to_sym] = conflicting_operand
              else
                expect_this_cd_to_fail.send("#{var}=", conflicting_operand)
              end
              expect_this_cd_to_fail.save
              refute(expect_this_cd_to_fail.approved?)
            else
              raise ModelNotRecognizedError('No implementation for #{model}')
            end
          end
        end
      end
    end
  end
end

def generate_conflicting_operand operator, operand
  # Based on the credit policy (using CPML), generate conflicting scenarios
  # i.e., if the policy says FICO must be GT than 600, generate a scenario where FICO is 599
  if (operator == 'EQ' && operand == 'false') || (operator == 'NEQ' && operand == 'true')
    conflicting_operand = true
  elsif (operator == 'EQ' && operand == 'true') || (operator == 'NEQ' && operand == 'false')
    conflicting_operand = false
  elsif operator == 'GT' || operator == 'NEQ' || operator == 'LT'
    conflicting_operand = operand
  elsif operator == 'GTE'
    conflicting_operand = operand - 1
  elsif operator == 'LTE' || operator == 'EQ'
    conflicting_operand = operand + 1
  end
end
