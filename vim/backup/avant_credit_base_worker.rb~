require 'resque'
require 'resque/errors'

# The autoloader heisenbug:
require_relative '../util'
require_relative '../util/alert'
require_relative '../util/config'
require_relative '../util/flow'

# @todo really, none of these except for #perform should be instance methods
module Resque::AvantCreditBaseWorker
  extend ActiveSupport::Concern

  FailedJobError        = Class.new(RuntimeError)
  DuringRequeueError    = Class.new(RuntimeError)
  MissingJobMethodError = Class.new(RuntimeError)

  LOW_PRIORITY_QUEUE      = :low
  NORMAL_PRIORITY_QUEUE   = :normal
  HIGH_PRIORITY_QUEUE     = :high
  CRITICAL_PRIORITY_QUEUE = :critical
  MAILER_QUEUE            = :mailer
  SPECIAL_QUEUE           = :special
  BACKPOPULATION_QUEUE    = :backpopulation
  CREDIT_REPORTS_QUEUE    = :credit_reports
  EVENTS_QUEUE            = :events
  LEAD_PROVIDER_QUEUE     = :lead_provider
  OVERSEER_QUEUE          = :overseer
  NOAA_QUEUE              = :noaa
  YODLEE_QUEUE            = :yodlee
  WARNINGS_QUEUE          = :warnings
  ELASTICSEARCH_QUEUE     = :elasticsearch
  AUTO_APPROVAL_QUEUE     = :auto_approval
  ATTR_SYNCHRONIZE_QUEUE  = :attr_synchronize
  COLLATERAL_QUEUE        = :collateral

  include Resque::Plugins::Status
  extend  Resque::AvantCreditScheduleWorker
  include Resque::AvantRetryable

  included do
    # default queue
    def self.queue
      @queue || NORMAL_PRIORITY_QUEUE
    end

    def self.before_enqueue_create_stat_record(*args)
      uuid, options = args

      JobEvent.track!(uuid,
      { job_class: self.name,
        job_name: options['job'],
        dyno: ENV['DYNO'],
        entered_at: Time.now,
        spawned_from: options['parent_job_uuid'],
        retry_parent: options['retry_parent']})

      # if you don't return a true value, the job will not get queued
      return true
    end

    # arguments to pass along to the job method
    attr_accessor :args
  end

  def perform
    @in_time = Time.now
    tick("starting job")
    emit_job_event('start')
    Rails.logger.info "Resque::AvantCreditBaseWorker calling #{self.class.name}##{method_name}(#{@options.inspect})"
    Resque::Plugin.before_hooks(self).each{|hook| send(hook) }
    # binding.pry
    raise(MissingJobMethodError, "##{method_name} is not defined in #{self.class.name}!") unless self.respond_to?(method_name.to_s)
    self.send(method_name.to_sym)
  rescue Resque::TermException
    emit_job_error('sigterm')
    kill!
  end

  def emit_job_event(event)
    EventEmitterProcessor.create('stat' => "app.job.#{class_name}.#{method_name}.#{event}", 'count' => '1', 't' => Time.now.to_i)
  end

  def emit_job_error(type)
    EventEmitterProcessor.create('stat' => "job.#{type}_error", 'count' => '1', 't' => Time.now.to_i)
  end

  def class_name
    self.class.name.underscore
  end

  def method_name
    @options['job']
  end

  def args
    @options['args']
  end

  def on_success
    emit_job_event("completed")
    track_job_status!
  end

  def on_failure(exception)
    # @note - should probably prevent jobs that fail because of MissingJobError from retrying
    emit_job_event("failed")
    track_job_status!
    retryable? ? retry_job! : raise(exception)
  end

  def on_killed
    emit_job_event("killed")
    track_job_status!
    retry_job! if retryable?
  end

  def track_job_status!
    JobEvent.track!(self.uuid, {in_time: @in_time, out_time: Time.now, result: status['status']})
  end
end
