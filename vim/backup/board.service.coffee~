'use strict'

angular.module 'threeManChessApp'
.factory 'Board', ($rootScope) ->

  drawMiddleCircle = () ->
    canvas = $rootScope.canvas
    ctx = $rootScope.ctx
    ctx.fillStyle = '#ccc'
    do ctx.beginPath
    ctx.moveTo(canvas.width / 2, canvas.height / 2)
    ctx.arc(
      canvas.width / 2,
      canvas.height / 2,
      canvas.height / 8,
      0,
      window.Math.PI * 2,
      false
    )
    do ctx.fill


  drawRivers = () ->
    ctx = $rootScope.ctx
    canvas = $rootScope.canvas
    
    start_at = [[300, 0], [560, 450], [40, 450]]
    river_end_at = [[300, 113], [462, 394], [139, 392]]
    moat_end_at = [[300, 113/3], [527, 431], [74, 430]]

    for i in [1..3]
      ctx.lineWidth='1'
      ctx.beginPath()
      ctx.moveTo(start_at[i][0], start_at[i][1])
      ctx.lineTo(river_end_at[i][0], river_end_at[i][1])
      ctx.stroke()
      ctx.lineWidth='3'
      ctx.beginPath()
      ctx.moveTo(start_at[i][0], start_at[i][1])
      ctx.lineTo(moat_end_at[i][0], moat_end_at[i][1])
      ctx.stroke()


  drawBoard: (highlights = [], beziers = []) ->
    lastend = 0
    data = []
    total = 24
    data.push(10) for i in [0...total]
    myTotal = 0
    myColor = ['#eeeeee', '#aabbff']
    canvas = $rootScope.canvas
    ctx = $rootScope.ctx

    for e in [0...data.length]
      myTotal += data[e]

    for rad in [0...6]
      for i in [0...data.length]
        ctx.fillStyle = myColor[(i + (rad % 2)) % 2]

        # hover
        for [x, y] in highlights
          if i == x && rad == y
            ctx.fillStyle = '#8899cc'
            ctx.fillStyle = '#6d7e9b' if (i+rad)%2 == 0

        # board drawing
        do ctx.beginPath
        ctx.moveTo canvas.width / 2, canvas.height / 2
        ctx.arc(
          canvas.width / 2,
          canvas.height / 2,
          canvas.height / 8 + ((1 / 2 - 1 / 8) * canvas.height) * 1 / 6 * (6 - rad),
          lastend,
          lastend + (window.Math.PI * 2 * (data[i]/myTotal)),
          false
        )
        ctx.lineTo canvas.width / 2, canvas.height / 2
        do ctx.fill
        lastend += window.Math.PI * 2 * data[i] / myTotal

    # Middle circle and rivers
    drawRivers()
    drawMiddleCircle()

    # Beziers
    for offset in beziers
      endpoints = []
      for sign in [-1..1] by 2
        i = 0
        pts = []
        lastend = (2 * offset + 1) / 2 * (window.Math.PI * 2 * (data[i]/myTotal))
        cnt = 0

        `for (i = 0; i < 9 && cnt < 10; i++) {
         cnt++;
          
         var x = (canvas.width/8 + ((6 - i)*1/6*((1/2 - 1/8) * canvas.width)));
         if (i == 1) x -= (canvas.width / 4) / 5;
         if (i - 1 % 3 == 0) x += canvas.width/20;
         if (i == 4) x -= canvas.width/40;
         if (i == 3 || i == 4 || i == 5) x += canvas.width/40;
         if (i == 8) x = -canvas.width * 1 / 10;
         x *= Math.cos(lastend);
         x += canvas.width/2 ;
         if (i == 8) x = canvas.width / 2;
           
         var y = (canvas.height/8 + ((6 - i)*1/6*((1/2 - 1/8) * canvas.height)));
         if (i - 1 % 3 == 0) y += canvas.width/20;
         if (i == 4) y -= canvas.width/40;
         if (i == 3 || i == 4 || i == 5) y += canvas.width/40;
         if (i == 1) y -= (canvas.width / 4) / 5;
         y *= Math.sin(lastend);
         y += canvas.height/2 ;

         pts.push(x);
         pts.push(y);

         if (cnt == 9) { // Store endpoints of two sides of the lasso 
                         // so we can draw the middle contour.
           endpoints.push(x)
           endpoints.push(y)
         }

         if (i == 0) lastend -= sign * 1/2 * Math.PI*2*(data[i]/myTotal);
           
         if (cnt > 0 && cnt % 3 == 0) {
           ctx.beginPath();
           eval("ctx.bezierCurveTo(" + pts.join(',') + ")");
           ctx.lineWidth = 0.5;
                   
           ctx.strokeStyle = 'black';
           ctx.stroke();
           pts = [];
           i -= 1;
         } else lastend += sign*Math.PI*2*(data[i]/myTotal);
        }`
    
      # Finally, use the endpoints of the two "split" halves of a lasso
      # to draw the remaining contour in the middle.
      init_angle = (2 * offset + 1) / 2 * (window.Math.PI * 2 * (data[i]/myTotal)) +
         1/2 * Math.PI*2*(data[i]/myTotal)
      x_mid = -canvas.width / 12 * Math.cos(init_angle)
      y_mid = -canvas.height / 12 * Math.sin(init_angle)
      # Debug! Draw a vector from the center of the board to the middle of the
      #  bezier contour.
      # ctx.beginPath()
      # ctx.moveTo(canvas.width / 2, canvas.height / 2)
      # ctx.lineTo(x_mid + canvas.width / 2, y_mid + canvas.height / 2)
      # ctx.stroke()
      ctx.beginPath()
      eval("ctx.bezierCurveTo(" + [endpoints[0], endpoints[1], canvas.width / 2 + x_mid,
        canvas.height / 2 + y_mid, endpoints[2], endpoints[3]].join(',') + ")")
      ctx.lineWidth = 0.5
      ctx.strokeStyle = 'black'
      ctx.stroke()


